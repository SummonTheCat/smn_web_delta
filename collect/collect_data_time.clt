-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\build_all.py ---
-------------------------------------------
#!/usr/bin/env python3
import json
import subprocess
import shutil
import os
from pathlib import Path


def run(cmd, cwd):
    print(f"[RUN] {cmd} (cwd={cwd})")
    subprocess.check_call(cmd, cwd=str(cwd), shell=True)


def copy_item(src: Path, dst: Path):
    if not src.exists():
        print(f"  [WARN] Missing: {src}")
        return

    if src.is_dir():
        shutil.copytree(src, dst / src.name, dirs_exist_ok=True)
    else:
        dst.mkdir(parents=True, exist_ok=True)
        shutil.copy2(src, dst / src.name)


def build_project(proj_path: Path, copy_list, output_root: Path):
    proj_name = proj_path.name
    print(f"\n=== Building {proj_name} ===")

    # Build release version
    run("cargo build --release", cwd=proj_path)

    target_release = proj_path / "target" / "release"
    out_dir = output_root / proj_name
    out_dir.mkdir(parents=True, exist_ok=True)

    # Detect platform binary name
    if os.name == "nt":
        expected_name = proj_name + ".exe"
    else:
        expected_name = proj_name  # Linux / macOS

    exe_path = target_release / expected_name

    # If missing, fall back to newest executable-like file
    if not exe_path.exists():
        print(f"  [WARN] Expected binary not found: {exe_path}")
        candidates = [
            p for p in target_release.iterdir()
            if p.is_file() and os.access(p, os.X_OK)
        ]

        if not candidates:
            raise FileNotFoundError(f"No executable produced for project: {proj_name}")

        exe_path = max(candidates, key=lambda p: p.stat().st_mtime)
        print(f"  Using fallback binary: {exe_path}")

    print(f"  Copying binary: {exe_path} -> {out_dir}")
    shutil.copy2(exe_path, out_dir / exe_path.name)

    # Copy extra files/directories
    for item in copy_list:
        src = proj_path / item
        print(f"  Copying extra: {src}")
        copy_item(src, out_dir)

    print(f"=== Done {proj_name} ===\n")


def main():
    script_dir = Path(__file__).resolve().parent
    config_file = script_dir / "build_config.json"
    if not config_file.exists():
        raise FileNotFoundError(f"Config file not found: {config_file}")

    with open(config_file, "r") as f:
        config = json.load(f)

    # IMPORTANT: output bin is relative to current working directory
    output_root = Path(config.get("output_bin", "bin")).resolve()
    output_root.mkdir(parents=True, exist_ok=True)

    for proj in config["projects"]:
        proj_path = Path(proj["path"]).resolve()
        copy_list = proj.get("copy", [])
        build_project(proj_path, copy_list, output_root)


if __name__ == "__main__":
    main()


-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\build_config.json ---
-------------------------------------------
{
    "projects": [
        {
            "path": "./smn_servers/smn_server_charmline",
            "copy": []
        },
        {
            "path": "./smn_servers/smn_server_get",
            "copy": []
        },
        {
            "path": "./smn_servers/smn_server_mora",
            "copy": []
        },
        {
            "path": "./smn_servers/smn_server_site",
            "copy": []
        }
    ],
    "output_bin": "bin"
}

-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\host_stack.json ---
-------------------------------------------
{
  "services": [
    {
      "name": "smn_server_charmline",
      "path": "./bin/smn_server_charmline/smn_server_charmline.exe"
    },
    {
      "name": "smn_server_get",
      "path": "./bin/smn_server_get/smn_server_get.exe"
    },
    {
      "name": "smn_server_mora",
      "path": "./bin/smn_server_mora/smn_server_mora.exe"
    },
    {
      "name": "smn_server_site",
      "path": "./bin/smn_server_site/smn_server_site.exe"
    }
  ]
}


-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\nginx_config.json ---
-------------------------------------------
{
    "baseAddress": "julienliakos.com",
    "sslCertificatePath": "/etc/letsencrypt/live/julienliakos.com/fullchain.pem",
    "sslCertificateKeyPath": "/etc/letsencrypt/live/julienliakos.com/privkey.pem",
    "nginxConfigPath": "/etc/nginx/sites-enabled/default",
    "servers": [
        {
            "subDomain": "",
            "port": 33030
        },
        {
            "subDomain": "get",
            "port": 33031
        }
    ]
}

-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\nginx_host.py ---
-------------------------------------------
#!/usr/bin/env python3
import json
import subprocess
from pathlib import Path


HTTP_TEMPLATE = """# ===============================
# {baseAddress} & subdomains
# ===============================

# --- Redirect all HTTP to HTTPS ---
server {{
    listen 80;
    listen [::]:80;
    server_name {all_domains};
    return 301 https://$host$request_uri;
}}
"""

HTTPS_TEMPLATE = """# --- HTTPS Server Block ---
server {{
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name {all_domains};

    # --- SSL Configuration ---
    ssl_certificate {ssl_certificate};
    ssl_certificate_key {ssl_certificate_key};
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    location / {{
{rules}

        # --- Default fallback (optional) ---
        return 404;
    }}

    # --- Proxy Headers ---
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
}}
"""


def run(cmd: str):
    print(f"[RUN] {cmd}")
    subprocess.check_call(cmd, shell=True)


def build_rule(subdomain: str, port: int, base: str) -> str:
    if subdomain == "":
        fqdn = base
        www_fqdn = f"www.{base}"

        return f"""        # --- {fqdn} traffic to port {port} ---
        if ($host = "{fqdn}") {{
            proxy_pass http://127.0.0.1:{port};
            break;
        }}

        if ($host = "{www_fqdn}") {{
            proxy_pass http://127.0.0.1:{port};
            break;
        }}"""

    else:
        fqdn = f"{subdomain}.{base}"
        return f"""        # --- {fqdn} traffic to port {port} ---
        if ($host = "{fqdn}") {{
            proxy_pass http://127.0.0.1:{port};
            break;
        }}"""


def acquire_certificate(domains):
    print("\n========================================")
    print(" Certbot SSL Certificate Acquisition")
    print("========================================\n")

    print("Certbot will now request SSL certificates for:")
    for d in domains:
        print(f"  - {d}")

    print("""
NOTE: You will be prompted by certbot for:
  • An email address
  • Agreement to Let's Encrypt Terms of Service
  • Optional marketing emails
  • HTTP validation confirmation

This is normal and required for certificate issuance.
""")

    domain_args = " ".join([f"-d {d}" for d in domains])

    cmd = f"certbot certonly --nginx {domain_args}"
    print("[INFO] Running Certbot…")
    run(cmd)

    print("[INFO] Certificate acquisition complete.\n")


def main():
    script_dir = Path(__file__).resolve().parent
    config_path = script_dir / "nginx_config.json"

    if not config_path.exists():
        raise FileNotFoundError(f"Missing nginx_config.json at {config_path}")

    with open(config_path, "r") as f:
        cfg = json.load(f)

    base = cfg["baseAddress"]
    cert_path = cfg["sslCertificatePath"]
    key_path = cfg["sslCertificateKeyPath"]
    out_path = Path(cfg["nginxConfigPath"])

    # Build hostname list
    domains = []
    for s in cfg["servers"]:
        sub = s["subDomain"]
        if sub == "":
            domains.append(base)
            domains.append("www." + base)
        else:
            domains.append(f"{sub}.{base}")

    # STEP 1 — Acquire certificate before generating config
    acquire_certificate(domains)

    # STEP 2 — Build nginx config
    all_domains = " ".join(domains)

    rule_blocks = []
    for s in cfg["servers"]:
        rule_blocks.append(build_rule(s["subDomain"], s["port"], base))

    rules_str = "\n\n".join(rule_blocks)

    http_block = HTTP_TEMPLATE.format(
        baseAddress=base,
        all_domains=all_domains
    )

    https_block = HTTPS_TEMPLATE.format(
        all_domains=all_domains,
        ssl_certificate=cert_path,
        ssl_certificate_key=key_path,
        rules=rules_str
    )

    final_config = http_block + "\n" + https_block

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(final_config, encoding="utf-8")

    print(f"Nginx configuration written to: {out_path}")
    print("Reloading nginx…")
    run("systemctl reload nginx")

    print("\nAll done.")


if __name__ == "__main__":
    main()


-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\stack_host.py ---
-------------------------------------------
#!/usr/bin/env python3
import json
import subprocess
import os
from pathlib import Path
import platform

def resolve_exec_path(raw_path: Path) -> Path:
    system = platform.system().lower()

    if system != "windows" and raw_path.suffix == ".exe":
        return raw_path.with_suffix("")

    if system == "windows" and raw_path.suffix != ".exe":
        return raw_path.with_suffix(".exe")

    return raw_path


def main():
    script_dir = Path(__file__).resolve().parent
    config_file = script_dir / "host_stack.json"

    if not config_file.exists():
        raise FileNotFoundError(f"Missing host_stack.json at {config_file}")

    with open(config_file, "r") as f:
        config = json.load(f)

    pid_file = script_dir / ".pids"
    if pid_file.exists():
        pid_file.unlink()

    system = platform.system().lower()
    processes = []

    for svc in config["services"]:
        name = svc["name"]

        # service path relative to current running directory
        raw_path = Path(svc["path"]).resolve()
        exec_path = resolve_exec_path(raw_path)

        print(f"Starting {name} -> {exec_path}")

        if not exec_path.exists():
            print(f"[WARN] Executable missing: {exec_path}")
            continue

        if system == "windows":
            proc = subprocess.Popen(
                [str(exec_path)],
                cwd=exec_path.parent,
                creationflags=subprocess.CREATE_NEW_PROCESS_GROUP,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            processes.append(proc)

        else:
            proc = subprocess.Popen(
                [str(exec_path)],
                cwd=exec_path.parent,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )

        processes.append(proc)

    # Write correct PIDs
    with open(pid_file, "w") as f:
        for p in processes:
            f.write(str(p.pid) + "\n")

    print("All services started.")


if __name__ == "__main__":
    main()


-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\stack_kill.py ---
-------------------------------------------
#!/usr/bin/env python3
import os
import signal
from pathlib import Path
import platform
import subprocess
import json


def kill_by_name(proc_name: str, system: str):
    print(f"  Killing by name: {proc_name}")

    try:
        if system == "windows":
            subprocess.call(
                ["taskkill", "/IM", proc_name, "/F"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
        else:
            subprocess.call(
                ["pkill", "-f", proc_name],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
    except Exception as e:
        print(f"    Error killing '{proc_name}': {e}")


def load_service_exec_names(script_dir: Path):
    host_stack = script_dir / "host_stack.json"
    if not host_stack.exists():
        return []

    try:
        with open(host_stack, "r") as f:
            data = json.load(f)
    except Exception:
        return []

    names = []
    for svc in data.get("services", []):
        raw = svc.get("path", "")
        if not raw:
            continue
        names.append(Path(raw).name)
    return names


def main():
    script_dir = Path(__file__).resolve().parent
    pid_file = script_dir / ".pids"
    system = platform.system().lower()

    # Load fallback executable names from host_stack.json
    exe_names = load_service_exec_names(script_dir)

    # Always try fallback kill
    print("Performing process cleanup...")

    # Kill by PID if present
    if pid_file.exists():
        with open(pid_file, "r") as f:
            pids = [line.strip() for line in f.readlines() if line.strip()]

        for pid_str in pids:
            try:
                pid = int(pid_str)
            except ValueError:
                continue

            print(f"Killing PID {pid}")

            try:
                if system == "windows":
                    subprocess.call(
                        ["taskkill", "/PID", str(pid), "/F"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
                else:
                    os.kill(pid, signal.SIGKILL)
            except Exception:
                pass

        pid_file.unlink()

    # Fallback: kill by executable name
    print("Running fallback cleanup...")
    for exe in exe_names:
        kill_by_name(exe, system)

    print("Cleanup complete.")
    

if __name__ == "__main__":
    main()


-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\update.py ---
-------------------------------------------
#!/usr/bin/env python3
import subprocess
import sys

def run(cmd):
    result = subprocess.run(cmd, shell=True)
    if result.returncode != 0:
        print(f"Command failed: {cmd}")
        sys.exit(result.returncode)

def main():
    print("This will reset the repository to match origin completely.")
    print("Local changes and untracked files will be LOST.")
    confirm = input("Continue? (yes/no): ").strip().lower()

    if confirm not in ("yes", "y"):
        print("Aborted.")
        return

    # Fetch latest changes
    print("\nFetching latest from origin...")
    run("git fetch --all --prune")

    # Determine current branch
    print("Detecting current branch...")
    branch = subprocess.check_output(
        "git rev-parse --abbrev-ref HEAD", shell=True
    ).decode().strip()

    print(f"Resetting to origin/{branch} ...")
    run(f"git reset --hard origin/{branch}")

    print("Cleaning untracked files...")
    run("git clean -fdx")

    print("\nRepository successfully updated and cleaned.")

if __name__ == "__main__":
    main()


