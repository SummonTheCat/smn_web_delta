-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\build_all.py ---
-------------------------------------------
#!/usr/bin/env python3
import json
import subprocess
import shutil
import os
from pathlib import Path


def run(cmd, cwd):
    print(f"[RUN] {cmd} (cwd={cwd})")
    subprocess.check_call(cmd, cwd=str(cwd), shell=True)


def copy_item(src: Path, dst: Path):
    if not src.exists():
        print(f"  [WARN] Missing: {src}")
        return

    if src.is_dir():
        shutil.copytree(src, dst / src.name, dirs_exist_ok=True)
    else:
        dst.mkdir(parents=True, exist_ok=True)
        shutil.copy2(src, dst / src.name)


def build_project(proj_path: Path, copy_list, output_root: Path):
    proj_name = proj_path.name
    print(f"\n=== Building {proj_name} ===")

    # Build release version
    run("cargo build --release", cwd=proj_path)

    target_release = proj_path / "target" / "release"
    out_dir = output_root / proj_name
    out_dir.mkdir(parents=True, exist_ok=True)

    # Detect platform binary name
    if os.name == "nt":
        expected_name = proj_name + ".exe"
    else:
        expected_name = proj_name  # Linux / macOS

    exe_path = target_release / expected_name

    # If missing, fall back to newest executable-like file
    if not exe_path.exists():
        print(f"  [WARN] Expected binary not found: {exe_path}")
        candidates = [
            p for p in target_release.iterdir()
            if p.is_file() and os.access(p, os.X_OK)
        ]

        if not candidates:
            raise FileNotFoundError(f"No executable produced for project: {proj_name}")

        exe_path = max(candidates, key=lambda p: p.stat().st_mtime)
        print(f"  Using fallback binary: {exe_path}")

    print(f"  Copying binary: {exe_path} -> {out_dir}")
    shutil.copy2(exe_path, out_dir / exe_path.name)

    # Copy extra files/directories
    for item in copy_list:
        src = proj_path / item
        print(f"  Copying extra: {src}")
        copy_item(src, out_dir)

    print(f"=== Done {proj_name} ===\n")


def main():
    script_dir = Path(__file__).resolve().parent
    config_file = script_dir / "build_config.json"
    if not config_file.exists():
        raise FileNotFoundError(f"Config file not found: {config_file}")

    with open(config_file, "r") as f:
        config = json.load(f)

    # IMPORTANT: output bin is relative to current working directory
    output_root = Path(config.get("output_bin", "bin")).resolve()
    output_root.mkdir(parents=True, exist_ok=True)

    for proj in config["projects"]:
        proj_path = Path(proj["path"]).resolve()
        copy_list = proj.get("copy", [])
        build_project(proj_path, copy_list, output_root)


if __name__ == "__main__":
    main()


-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\build_config.json ---
-------------------------------------------
{
    "projects": [
        {
            "path": "./smn_servers/smn_server_charmline",
            "copy": []
        },
        {
            "path": "./smn_servers/smn_server_get",
            "copy": []
        },
        {
            "path": "./smn_servers/smn_server_mora",
            "copy": []
        },
        {
            "path": "./smn_servers/smn_server_site",
            "copy": []
        }
    ],
    "output_bin": "bin"
}

-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\host_stack.json ---
-------------------------------------------
{
  "services": [
    {
      "name": "smn_server_charmline",
      "path": "./bin/smn_server_charmline/smn_server_charmline.exe"
    },
    {
      "name": "smn_server_get",
      "path": "./bin/smn_server_get/smn_server_get.exe"
    },
    {
      "name": "smn_server_mora",
      "path": "./bin/smn_server_mora/smn_server_mora.exe"
    },
    {
      "name": "smn_server_site",
      "path": "./bin/smn_server_site/smn_server_site.exe"
    }
  ]
}


-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\nginx_host.py ---
-------------------------------------------


-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\stack_host.py ---
-------------------------------------------
#!/usr/bin/env python3
import json
import subprocess
import os
from pathlib import Path
import platform

def resolve_exec_path(raw_path: Path) -> Path:
    system = platform.system().lower()

    if system != "windows" and raw_path.suffix == ".exe":
        return raw_path.with_suffix("")

    if system == "windows" and raw_path.suffix != ".exe":
        return raw_path.with_suffix(".exe")

    return raw_path


def main():
    script_dir = Path(__file__).resolve().parent
    config_file = script_dir / "host_stack.json"

    if not config_file.exists():
        raise FileNotFoundError(f"Missing host_stack.json at {config_file}")

    with open(config_file, "r") as f:
        config = json.load(f)

    pid_file = script_dir / ".pids"
    if pid_file.exists():
        pid_file.unlink()

    system = platform.system().lower()
    processes = []

    for svc in config["services"]:
        name = svc["name"]

        # service path relative to current running directory
        raw_path = Path(svc["path"]).resolve()
        exec_path = resolve_exec_path(raw_path)

        print(f"Starting {name} -> {exec_path}")

        if not exec_path.exists():
            print(f"[WARN] Executable missing: {exec_path}")
            continue

        if system == "windows":
            proc = subprocess.Popen(
                [str(exec_path)],
                cwd=exec_path.parent,
                creationflags=subprocess.CREATE_NEW_PROCESS_GROUP,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            processes.append(proc)

        else:
            proc = subprocess.Popen(
                [str(exec_path)],
                cwd=exec_path.parent,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )

        processes.append(proc)

    # Write correct PIDs
    with open(pid_file, "w") as f:
        for p in processes:
            f.write(str(p.pid) + "\n")

    print("All services started.")


if __name__ == "__main__":
    main()


-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\stack_kill.py ---
-------------------------------------------
#!/usr/bin/env python3
import os
import signal
from pathlib import Path
import platform
import subprocess
import json


def kill_by_name(proc_name: str, system: str):
    print(f"  Killing by name: {proc_name}")

    try:
        if system == "windows":
            subprocess.call(
                ["taskkill", "/IM", proc_name, "/F"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
        else:
            subprocess.call(
                ["pkill", "-f", proc_name],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
    except Exception as e:
        print(f"    Error killing '{proc_name}': {e}")


def load_service_exec_names(script_dir: Path):
    host_stack = script_dir / "host_stack.json"
    if not host_stack.exists():
        return []

    try:
        with open(host_stack, "r") as f:
            data = json.load(f)
    except Exception:
        return []

    names = []
    for svc in data.get("services", []):
        raw = svc.get("path", "")
        if not raw:
            continue
        names.append(Path(raw).name)
    return names


def main():
    script_dir = Path(__file__).resolve().parent
    pid_file = script_dir / ".pids"
    system = platform.system().lower()

    # Load fallback executable names from host_stack.json
    exe_names = load_service_exec_names(script_dir)

    # Always try fallback kill
    print("Performing process cleanup...")

    # Kill by PID if present
    if pid_file.exists():
        with open(pid_file, "r") as f:
            pids = [line.strip() for line in f.readlines() if line.strip()]

        for pid_str in pids:
            try:
                pid = int(pid_str)
            except ValueError:
                continue

            print(f"Killing PID {pid}")

            try:
                if system == "windows":
                    subprocess.call(
                        ["taskkill", "/PID", str(pid), "/F"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
                else:
                    os.kill(pid, signal.SIGKILL)
            except Exception:
                pass

        pid_file.unlink()

    # Fallback: kill by executable name
    print("Running fallback cleanup...")
    for exe in exe_names:
        kill_by_name(exe, system)

    print("Cleanup complete.")
    

if __name__ == "__main__":
    main()


-------------------------------------------
--- \\?\E:\Summon\Projects\Web\smn_web_delta\tools\update.py ---
-------------------------------------------
#!/usr/bin/env python3
import subprocess
import sys

def run(cmd):
    result = subprocess.run(cmd, shell=True)
    if result.returncode != 0:
        print(f"Command failed: {cmd}")
        sys.exit(result.returncode)

def main():
    print("This will reset the repository to match origin completely.")
    print("Local changes and untracked files will be LOST.")
    confirm = input("Continue? (yes/no): ").strip().lower()

    if confirm not in ("yes", "y"):
        print("Aborted.")
        return

    # Fetch latest changes
    print("\nFetching latest from origin...")
    run("git fetch --all --prune")

    # Determine current branch
    print("Detecting current branch...")
    branch = subprocess.check_output(
        "git rev-parse --abbrev-ref HEAD", shell=True
    ).decode().strip()

    print(f"Resetting to origin/{branch} ...")
    run(f"git reset --hard origin/{branch}")

    print("Cleaning untracked files...")
    run("git clean -fdx")

    print("\nRepository successfully updated and cleaned.")

if __name__ == "__main__":
    main()


